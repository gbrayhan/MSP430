<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MSP430 Peripheral Driver Library: adc12.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="$relpath/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="$relpath/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<!-- Generated by Doxygen 1.7.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">adc12.c File Reference</div>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="adc12_8h_source.html">driverlib/5xx_6xx/adc12.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="hw__types_8h_source.html">inc/hw_types.h</a>&quot;</code><br/>
<code>#include &quot;msp430xgeneric.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="debug_8h_source.html">driverlib/5xx_6xx/debug.h</a>&quot;</code><br/>
</div><table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc12_8c.html#a50515d238ff775ed34d66a5f5e449f5e">ADC12_init</a> (unsigned int baseAddress, unsigned int sampleHoldSignalSourceSelect, unsigned char clockSourceSelect, unsigned int clockSourceDivider)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc12_8c.html#ae9ef6d5c3a9d8f21a983f9b2b6c7f4f4">ADC12_enable</a> (unsigned int baseAddress)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc12_8c.html#aa92354a61ce5685c05fb8c01e81ad82b">ADC12_disable</a> (unsigned int baseAddress)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc12_8c.html#abe73e4377d4898106655cdff1bb77b9a">ADC12_setupSamplingTimer</a> (unsigned int baseAddress, unsigned int clockCycleHoldCountLowMem, unsigned int clockCycleHoldCountHighMem, unsigned short multipleSamplesEnabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc12_8c.html#a1696aae256b9ded74f227ba44516cafa">ADC12_disableSamplingTimer</a> (unsigned int baseAddress)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc12_8c.html#a19add46e9273bc82d95d8d465a8cbece">ADC12_memoryConfigure</a> (unsigned int baseAddress, unsigned char memoryBufferControlIndex, unsigned char inputSourceSelect, unsigned char positiveRefVoltageSourceSelect, unsigned char negativeRefVoltageSourceSelect, unsigned short endOfSequence)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc12_8c.html#a44acf1f208e3bb6fa8020934a5ea91f3">ADC12_enableInterrupt</a> (unsigned int baseAddress, unsigned long interruptMask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc12_8c.html#a91ee3d347bb9cda4b43becc5ca2a7ddb">ADC12_disableInterrupt</a> (unsigned int baseAddress, unsigned long interruptMask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc12_8c.html#a75a110e7a6378475229cdd44ffbed6be">ADC12_clearInterrupt</a> (unsigned int baseAddress, unsigned int memoryInterruptFlagMask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc12_8c.html#a0506181ef3eac1876e7d5dc6680004c1">ADC12_getInterruptStatus</a> (unsigned int baseAddress, unsigned int memoryInterruptFlagMask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc12_8c.html#a297b08a9a330166818a3991eb220177e">ADC12_startConversion</a> (unsigned int baseAddress, unsigned int startingMemoryBufferIndex, unsigned char conversionSequenceModeSelect)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc12_8c.html#a7a81cbe39c2fdd262cbdd6407559a882">ADC12_disableConversions</a> (unsigned int baseAddress, unsigned short preempt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc12_8c.html#a1f625d54871ddb415f907f9b3e7c4b2f">ADC12_getResults</a> (unsigned int baseAddress, unsigned char memoryBufferIndex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc12_8c.html#a8d7dbf6939271d728126e3898ccf84ba">ADC12_setResolution</a> (unsigned int baseAddress, unsigned char resolutionSelect)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc12_8c.html#a8306114b51f21a79105ffd6808697604">ADC12_setSampleHoldSignalInversion</a> (unsigned int baseAddress, unsigned int invertedSignal)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc12_8c.html#a045b246fcc1155af2a579acd0b02796a">ADC12_setDataReadBackFormat</a> (unsigned int baseAddress, unsigned short readBackFormat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc12_8c.html#a38cf5c993556c54a83ae9e69f09abba2">ADC12_enableReferenceBurst</a> (unsigned int baseAddress)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc12_8c.html#a82ea657873bd5d0d42109f536687a240">ADC12_disableReferenceBurst</a> (unsigned int baseAddress)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc12_8c.html#aa6a7531c03e3a27259a87a6b117c6f3b">ADC12_setReferenceBufferSamplingRate</a> (unsigned int baseAddress, unsigned short samplingRateSelect)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc12_8c.html#a020dda8a075980e22bf9f98e45ef1164">ADC12_getMemoryAddressForDMA</a> (unsigned int baseAddress, unsigned char memoryIndex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adc12_8c.html#ad353c636458e86515ff6f522d61f7fe9">ADC12_isBusy</a> (unsigned int baseAddress)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a50515d238ff775ed34d66a5f5e449f5e"></a><!-- doxytag: member="adc12.c::ADC12_init" ref="a50515d238ff775ed34d66a5f5e449f5e" args="(unsigned int baseAddress, unsigned int sampleHoldSignalSourceSelect, unsigned char clockSourceSelect, unsigned int clockSourceDivider)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short ADC12_init </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sampleHoldSignalSourceSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>clockSourceSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>clockSourceDivider</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes the ADC12 Module.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12 module. </td></tr>
    <tr><td class="paramname">sampleHoldSignalSourceSelect</td><td>is the signal that will trigger a sample-and-hold for an input signal to be converted. Valid values are <b>ADC12_SAMPLEHOLDSOURCE_SC</b> [Default] <b>ADC12_SAMPLEHOLDSOURCE_1</b> <b>ADC12_SAMPLEHOLDSOURCE_2</b> <b>ADC12_SAMPLEHOLDSOURCE_3</b> This parameter is device specific and sources should be found in the device's datasheet. Modified bits are <b>ADC12SHSx</b> of <b>ADC12CTL1</b> register. </td></tr>
    <tr><td class="paramname">clockSourceSelect</td><td>selects the clock that will be used by the ADC12 core, and the sampling timer if a sampling pulse mode is enabled. Valid values are <b>ADC12_CLOCKSOURCE_ADC12OSC</b> - MODOSC 5 MHz oscillator from the UCS [Default] <b>ADC12_CLOCKSOURCE_ACLK</b> - The Auxilary Clock <b>ADC12_CLOCKSOURCE_MCLK</b> - The Master Clock <b>ADC12_CLOCKSOURCE_SMCLK</b> - The Sub-Master Clock Modified bits are <b>ADC12SSELx</b> of <b>ADC12CTL1</b> register. </td></tr>
    <tr><td class="paramname">clockSourceDivider</td><td>selects the amount that the clock will be divided. Valid values are <b>ADC12_CLOCKDIVIDER_1</b> [Default] <b>ADC12_CLOCKDIVIDER_2</b> <b>ADC12_CLOCKDIVIDER_3</b> <b>ADC12_CLOCKDIVIDER_4</b> <b>ADC12_CLOCKDIVIDER_5</b> <b>ADC12_CLOCKDIVIDER_6</b> <b>ADC12_CLOCKDIVIDER_7</b> <b>ADC12_CLOCKDIVIDER_8</b> <b>ADC12_CLOCKDIVIDER_12</b> <b>ADC12_CLOCKDIVIDER_16</b> <b>ADC12_CLOCKDIVIDER_20</b> <b>ADC12_CLOCKDIVIDER_24</b> <b>ADC12_CLOCKDIVIDER_28</b> <b>ADC12_CLOCKDIVIDER_32</b> Modified bits are <b>ADC12DIVx</b> of <b>ADC12CTL1</b> register and <b>ADC12PDIV</b> of <b>ADC12CTL2</b> register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function initializes the ADC module to allow for analog-to-digital conversions. Specifically this function sets up the sample-and-hold signal and clock sources for the ADC core to use for conversions. Upon successful completion of the initialization all of the ADC control registers will be reset, excluding the memory controls and reference module bits, the given parameters will be set, and the ADC core will be turned on (Note, that the ADC core only draws power during conversions and remains off when not converting).Note that sample/hold signal sources are device dependent. Note that if re-initializing the ADC after starting a conversion with the startConversion() function, the disableConversion() must be called BEFORE this function can be called.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>STATUS_SUCCESS or STATUS_FAILURE of the initialization process. </dd></dl>

<p>References <a class="el" href="adc12_8h.html#a8c13f1599a12657d970e72df23dd03ff">ADC12_CLOCKDIVIDER_32</a>, <a class="el" href="adc12_8h.html#ad3a6fb4035f26e1d74e5550795921291">ADC12_CLOCKSOURCE_SMCLK</a>, <a class="el" href="adc12_8h.html#a8a628ac7612b39934aebb1e8c8a88760">ADC12_SAMPLEHOLDSOURCE_3</a>, <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, <a class="el" href="hw__types_8h.html#a084083ee12e5262f8e54bb56c15ac8c7">HWREGB</a>, and <a class="el" href="hw__memmap_8h.html#ae56fdb340b23940f7a64ed2e37c1774a">STATUS_SUCCESS</a>.</p>

</div>
</div>
<a class="anchor" id="ae9ef6d5c3a9d8f21a983f9b2b6c7f4f4"></a><!-- doxytag: member="adc12.c::ADC12_enable" ref="ae9ef6d5c3a9d8f21a983f9b2b6c7f4f4" args="(unsigned int baseAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_enable </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>baseAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enables the ADC12 block.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12 module.</td></tr>
  </table>
  </dd>
</dl>
<p>This will enable operation of the ADC12 block. Modified bits are <b>ADC12ON</b> of <b>ADC12CTL0</b> register.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>References <a class="el" href="hw__types_8h.html#a084083ee12e5262f8e54bb56c15ac8c7">HWREGB</a>.</p>

</div>
</div>
<a class="anchor" id="aa92354a61ce5685c05fb8c01e81ad82b"></a><!-- doxytag: member="adc12.c::ADC12_disable" ref="aa92354a61ce5685c05fb8c01e81ad82b" args="(unsigned int baseAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_disable </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>baseAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disables the ADC12 block.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12 module.</td></tr>
  </table>
  </dd>
</dl>
<p>This will disable operation of the ADC12 block. Modified bits are <b>ADC12ON</b> of <b>ADC12CTL0</b> register.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

<p>References <a class="el" href="hw__types_8h.html#a084083ee12e5262f8e54bb56c15ac8c7">HWREGB</a>.</p>

</div>
</div>
<a class="anchor" id="abe73e4377d4898106655cdff1bb77b9a"></a><!-- doxytag: member="adc12.c::ADC12_setupSamplingTimer" ref="abe73e4377d4898106655cdff1bb77b9a" args="(unsigned int baseAddress, unsigned int clockCycleHoldCountLowMem, unsigned int clockCycleHoldCountHighMem, unsigned short multipleSamplesEnabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_setupSamplingTimer </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>clockCycleHoldCountLowMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>clockCycleHoldCountHighMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>multipleSamplesEnabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets up and enables the Sampling Timer Pulse Mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12 module. </td></tr>
    <tr><td class="paramname">clockCycleHoldCountLowMem</td><td>sets the amount of clock cycles to sample-and-hold for the higher memory buffers 0-7. Valid values are <b>ADC12_CYCLEHOLD_4_CYCLES</b> [Default] <b>ADC12_CYCLEHOLD_8_CYCLES</b> <b>ADC12_CYCLEHOLD_16_CYCLES</b> <b>ADC12_CYCLEHOLD_32_CYCLES</b> <b>ADC12_CYCLEHOLD_64_CYCLES</b> <b>ADC12_CYCLEHOLD_96_CYCLES</b> <b>ADC12_CYCLEHOLD_128_CYCLES</b> <b>ADC12_CYCLEHOLD_192_CYCLES</b> <b>ADC12_CYCLEHOLD_256_CYCLES</b> <b>ADC12_CYCLEHOLD_384_CYCLES</b> <b>ADC12_CYCLEHOLD_512_CYCLES</b> <b>ADC12_CYCLEHOLD_768_CYCLES</b> <b>ADC12_CYCLEHOLD_1024_CYCLES</b> Modified bits are <b>ADC12SHT0x</b> of <b>ADC12CTL0</b> register. </td></tr>
    <tr><td class="paramname">clockCycleHoldCountHighMem</td><td>sets the amount of clock cycles to sample-and-hold for the higher memory buffers 8-15. Valid values are <b>ADC12_CYCLEHOLD_4_CYCLES</b> [Default] <b>ADC12_CYCLEHOLD_8_CYCLES</b> <b>ADC12_CYCLEHOLD_16_CYCLES</b> <b>ADC12_CYCLEHOLD_32_CYCLES</b> <b>ADC12_CYCLEHOLD_64_CYCLES</b> <b>ADC12_CYCLEHOLD_96_CYCLES</b> <b>ADC12_CYCLEHOLD_128_CYCLES</b> <b>ADC12_CYCLEHOLD_192_CYCLES</b> <b>ADC12_CYCLEHOLD_256_CYCLES</b> <b>ADC12_CYCLEHOLD_384_CYCLES</b> <b>ADC12_CYCLEHOLD_512_CYCLES</b> <b>ADC12_CYCLEHOLD_768_CYCLES</b> <b>ADC12_CYCLEHOLD_1024_CYCLES</b> Modified bits are <b>ADC12SHT1x</b> of <b>ADC12CTL0</b> register. </td></tr>
    <tr><td class="paramname">multipleSamplesEnabled</td><td>allows multiple conversions to start without a trigger signal from the sample/hold signal Valid values are <b>ADC12_MULTIPLESAMPLESDISABLE</b> - a timer trigger will be needed to start every ADC conversion. [Default] <b>ADC12_MULTIPLESAMPLESENABLE</b> - during a sequenced and/or repeated conversion mode, after the first conversion, no sample/hold signal is necessary to start subsequent sample/hold and convert processes. Modified bits are <b>ADC12MSC</b> of <b>ADC12CTL0</b> register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets up the sampling timer pulse mode which allows the sample/hold signal to trigger a sampling timer to sample-and-hold an input signal for a specified number of clock cycles without having to hold the sample/hold signal for the entire period of sampling. Note that if a conversion has been started with the startConversion() function, then a call to disableConversions() is required before this function may be called.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

<p>References <a class="el" href="adc12_8h.html#ad02e18d57f3d518b5bef218c218a9939">ADC12_CYCLEHOLD_1024_CYCLES</a>, <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__types_8h.html#a084083ee12e5262f8e54bb56c15ac8c7">HWREGB</a>.</p>

</div>
</div>
<a class="anchor" id="a1696aae256b9ded74f227ba44516cafa"></a><!-- doxytag: member="adc12.c::ADC12_disableSamplingTimer" ref="a1696aae256b9ded74f227ba44516cafa" args="(unsigned int baseAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_disableSamplingTimer </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>baseAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disables Sampling Timer Pulse Mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12 module.</td></tr>
  </table>
  </dd>
</dl>
<p>Disables the Sampling Timer Pulse Mode. Note that if a conversion has been started with the startConversion() function, then a call to disableConversions() is required before this function may be called.</p>
<p>Modified bits are <b>ADC12SHP</b> of <b>ADC12CTL0</b> register. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__types_8h.html#a084083ee12e5262f8e54bb56c15ac8c7">HWREGB</a>.</p>

</div>
</div>
<a class="anchor" id="a19add46e9273bc82d95d8d465a8cbece"></a><!-- doxytag: member="adc12.c::ADC12_memoryConfigure" ref="a19add46e9273bc82d95d8d465a8cbece" args="(unsigned int baseAddress, unsigned char memoryBufferControlIndex, unsigned char inputSourceSelect, unsigned char positiveRefVoltageSourceSelect, unsigned char negativeRefVoltageSourceSelect, unsigned short endOfSequence)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_memoryConfigure </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>memoryBufferControlIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>inputSourceSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>positiveRefVoltageSourceSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>negativeRefVoltageSourceSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>endOfSequence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configures the controls of the selected memory buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12 module. </td></tr>
    <tr><td class="paramname">memoryBufferControlIndex</td><td>is the selected memory buffer to set the configuration for. Valid values are <b>ADC12_MEMORY_0</b> [Default] <b>ADC12_MEMORY_1</b> <b>ADC12_MEMORY_2</b> <b>ADC12_MEMORY_3</b> <b>ADC12_MEMORY_4</b> <b>ADC12_MEMORY_5</b> <b>ADC12_MEMORY_6</b> <b>ADC12_MEMORY_7</b> <b>ADC12_MEMORY_8</b> <b>ADC12_MEMORY_9</b> <b>ADC12_MEMORY_10</b> <b>ADC12_MEMORY_11</b> <b>ADC12_MEMORY_12</b> <b>ADC12_MEMORY_13</b> <b>ADC12_MEMORY_14</b> <b>ADC12_MEMORY_15</b> </td></tr>
    <tr><td class="paramname">inputSourceSelect</td><td>is the input that will store the converted data into the specified memory buffer. Valid values are <b>ADC12_INPUT_A0</b> [Default] <b>ADC12_INPUT_A1</b> <b>ADC12_INPUT_A2</b> <b>ADC12_INPUT_A3</b> <b>ADC12_INPUT_A4</b> <b>ADC12_INPUT_A5</b> <b>ADC12_INPUT_A6</b> <b>ADC12_INPUT_A7</b> <b>ADC12_INPUT_A8</b> <b>ADC12_INPUT_A9</b> <b>ADC12_INPUT_TEMPSENSOR</b> <b>ADC12_INPUT_BATTERYMONITOR</b> <b>ADC12_INPUT_A12</b> <b>ADC12_INPUT_A13</b> <b>ADC12_INPUT_A14</b> <b>ADC12_INPUT_A15</b> Modified bits are <b>ADC12INCHx</b> of <b>ADC12MCTLx</b> register. </td></tr>
    <tr><td class="paramname">positiveRefVoltageSourceSelect</td><td>is the reference voltage source to set as the upper limit for the conversion stored in the specified memory. Valid values are <b>ADC12_VREFPOS_AVCC</b> [Default] <b>ADC12_VREFPOS_EXT</b> <b>ADC12_VREFPOS_INT</b> Modified bits are <b>ADC12SREF</b> of <b>ADC12MCTLx</b> register. </td></tr>
    <tr><td class="paramname">negativeRefVoltageSourceSelect</td><td>is the reference voltage source to set as the lower limit for the conversion stored in the specified memory. Valid values are <b>ADC12_VREFNEG_AVSS</b> [Default] <b>ADC12_VREFNEG_EXT</b> Modified bits are <b>ADC12SREF</b> of <b>ADC12MCTLx</b> register. </td></tr>
    <tr><td class="paramname">endOfSequence</td><td>indicates that the specified memory buffer will be the end of the sequence if a sequenced conversion mode is selected Valid values are <b>ADC12_NOTENDOFSEQUENCE</b> - The specified memory buffer will NOT be the end of the sequence OR a sequenced conversion mode is not selected. [Default] <b>ADC12_ENDOFSEQUENCE</b> - The specified memory buffer will be the end of the sequence. Modified bits are <b>ADC12EOS</b> of <b>ADC12MCTLx</b> register.</td></tr>
  </table>
  </dd>
</dl>
<p>Maps an input signal conversion into the selected memory buffer, as well as the positive and negative reference voltages for each conversion being stored into this memory buffer. If the internal reference is used for the positive reference voltage, the internal REF module must be used to control the voltage level. Note that if a conversion has been started with the startConversion() function, then a call to disableConversions() is required before this function may be called.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

<p>References <a class="el" href="adc12_8h.html#ad293ef7b95e9a9141a82bb724d108b78">ADC12_INPUT_A15</a>, <a class="el" href="adc12_8h.html#a62fd4ee96c1eae548fdf8bca1fc8e259">ADC12_MEMORY_15</a>, <a class="el" href="adc12_8h.html#a20581378f123816ac3b795c03a9b0a91">ADC12_VREFNEG_EXT</a>, <a class="el" href="adc12_8h.html#a4c7cfd0521344dde75f5c284e7aeb069">ADC12_VREFPOS_INT</a>, <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, and <a class="el" href="hw__types_8h.html#a084083ee12e5262f8e54bb56c15ac8c7">HWREGB</a>.</p>

</div>
</div>
<a class="anchor" id="a44acf1f208e3bb6fa8020934a5ea91f3"></a><!-- doxytag: member="adc12.c::ADC12_enableInterrupt" ref="a44acf1f208e3bb6fa8020934a5ea91f3" args="(unsigned int baseAddress, unsigned long interruptMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_enableInterrupt </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enables selected ADC12 interrupt sources.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12 module. </td></tr>
    <tr><td class="paramname">memoryInterruptMask</td><td>is the bit mask of the memory buffer and overflow interrupt sources to be enabled. Mask values is the logical OR of any of the following <b>ADC12IE0</b> - new conversion data in the 0th memory buffer <b>ADC12IE1</b> - new conversion data in the 1st memory buffer <b>ADC12IE2</b> - new conversion data in the 2nd memory buffer <b>ADC12IE3</b> - new conversion data in the 3rd memory buffer <b>ADC12IE4</b> - new conversion data in the 4th memory buffer <b>ADC12IE5</b> - new conversion data in the 5th memory buffer <b>ADC12IE6</b> - new conversion data in the 6th memory buffer <b>ADC12IE7</b> - new conversion data in the 7th memory buffer <b>ADC12IE8</b> - new conversion data in the 8th memory buffer <b>ADC12IE9</b> - new conversion data in the 9th memory buffer <b>ADC12IE10</b> - new conversion data in the 10th memory buffer <b>ADC12IE11</b> - new conversion data in the 11th memory buffer <b>ADC12IE12</b> - new conversion data in the 12th memory buffer <b>ADC12IE13</b> - new conversion data in the 13th memory buffer <b>ADC12IE14</b> - new conversion data in the 14th memory buffer <b>ADC12IE15</b> - new conversion data in the 15th memory buffer <b>ADC12OVIE0</b> - a conversion is about to save to a memory buffer that has not been read out yet. <b>ADC12TOVIE0</b> - a conversion is about to start before the previous conversion has been completed.</td></tr>
  </table>
  </dd>
</dl>
<p>Enables the indicated ADC12 interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

<p>References <a class="el" href="adc12_8h.html#ae573731856857859e5b64cb6bfa8b5ea">ADC12OVIE0</a>, <a class="el" href="adc12_8h.html#a7a9088250d6d8054f4313dd595b32be4">ADC12TOVIE0</a>, and <a class="el" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a class="anchor" id="a91ee3d347bb9cda4b43becc5ca2a7ddb"></a><!-- doxytag: member="adc12.c::ADC12_disableInterrupt" ref="a91ee3d347bb9cda4b43becc5ca2a7ddb" args="(unsigned int baseAddress, unsigned long interruptMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_disableInterrupt </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disables selected ADC12 interrupt sources.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12 module. </td></tr>
    <tr><td class="paramname">memoryInterruptMask</td><td>is the bit mask of the memory buffer and overflow interrupt sources to be disabled. Mask values is the logical OR of any of the following <b>ADC12IE0</b> - new conversion data in the 0th memory buffer <b>ADC12IE1</b> - new conversion data in the 1st memory buffer <b>ADC12IE2</b> - new conversion data in the 2nd memory buffer <b>ADC12IE3</b> - new conversion data in the 3rd memory buffer <b>ADC12IE4</b> - new conversion data in the 4th memory buffer <b>ADC12IE5</b> - new conversion data in the 5th memory buffer <b>ADC12IE6</b> - new conversion data in the 6th memory buffer <b>ADC12IE7</b> - new conversion data in the 7th memory buffer <b>ADC12IE8</b> - new conversion data in the 8th memory buffer <b>ADC12IE9</b> - new conversion data in the 9th memory buffer <b>ADC12IE10</b> - new conversion data in the 10th memory buffer <b>ADC12IE11</b> - new conversion data in the 11th memory buffer <b>ADC12IE12</b> - new conversion data in the 12th memory buffer <b>ADC12IE13</b> - new conversion data in the 13th memory buffer <b>ADC12IE14</b> - new conversion data in the 14th memory buffer <b>ADC12IE15</b> - new conversion data in the 15th memory buffer <b>ADC12OVIE0</b> - a conversion is about to save to a memory buffer that has not been read out yet. <b>ADC12TOVIE0</b> - a conversion is about to start before the previous conversion has been completed.</td></tr>
  </table>
  </dd>
</dl>
<p>Disables the indicated ADC12 interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor.</p>
<p>Modified registers are <b>ADC12CTL0</b> and <b>ADC12IE</b>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

<p>References <a class="el" href="adc12_8h.html#ae573731856857859e5b64cb6bfa8b5ea">ADC12OVIE0</a>, <a class="el" href="adc12_8h.html#a7a9088250d6d8054f4313dd595b32be4">ADC12TOVIE0</a>, and <a class="el" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a class="anchor" id="a75a110e7a6378475229cdd44ffbed6be"></a><!-- doxytag: member="adc12.c::ADC12_clearInterrupt" ref="a75a110e7a6378475229cdd44ffbed6be" args="(unsigned int baseAddress, unsigned int memoryInterruptFlagMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_clearInterrupt </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>memoryInterruptFlagMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clears ADC12 selected interrupt flags.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12 module. </td></tr>
    <tr><td class="paramname">memoryInterruptFlagMask</td><td>is a bit mask of the interrupt flags to be cleared. Mask value is the logical OR of any of the following <b>OFS_ADC12IFG0</b> - Flag the 0th memory buffer interrupt <b>OFS_ADC12IFG1</b> - Flag the 1st memory buffer interrupt <b>OFS_ADC12IFG2</b> - Flag the 2nd memory buffer interrupt <b>OFS_ADC12IFG3</b> - Flag the 3rd memory buffer interrupt <b>OFS_ADC12IFG4</b> - Flag the 4th memory buffer interrupt <b>OFS_ADC12IFG5</b> - Flag the 5th memory buffer interrupt <b>OFS_ADC12IFG6</b> - Flag the 6th memory buffer interrupt <b>OFS_ADC12IFG7</b> - Flag the 7th memory buffer interrupt <b>OFS_ADC12IFG8</b> - Flag the 8th memory buffer interrupt <b>OFS_ADC12IFG9</b> - Flag the 9th memory buffer interrupt <b>OFS_ADC12IFG10</b> - Flag the 10th memory buffer interrupt <b>OFS_ADC12IFG11</b> - Flag the 11th memory buffer interrupt <b>OFS_ADC12IFG12</b> - Flag the 12th memory buffer interrupt <b>OFS_ADC12IFG13</b> - Flag the 13th memory buffer interrupt <b>OFS_ADC12IFG14</b> - Flag the 14th memory buffer interrupt <b>OFS_ADC12IFG15</b> - Flag the 15th memory buffer interrupt</td></tr>
  </table>
  </dd>
</dl>
<p>The selected ADC12 interrupt flags are cleared, so that it no longer asserts. The memory buffer interrupt flags are only cleared when the memory buffer is accessed. Note that the overflow interrupts do not have an interrupt flag to clear; they must be accessed directly from the interrupt vector.</p>
<p>Modified registers are <b>ADC12IFG</b>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

<p>References <a class="el" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a class="anchor" id="a0506181ef3eac1876e7d5dc6680004c1"></a><!-- doxytag: member="adc12.c::ADC12_getInterruptStatus" ref="a0506181ef3eac1876e7d5dc6680004c1" args="(unsigned int baseAddress, unsigned int memoryInterruptFlagMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char ADC12_getInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>memoryInterruptFlagMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the status of the selected memory interrupt flags.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12 module. </td></tr>
    <tr><td class="paramname">memoryInterruptFlagMask</td><td>is a bit mask of the interrupt flags status to be returned. Mask value is the logical OR of any of the following <b>OFS_ADC12IFG0</b> - Flag the 0th memory buffer interrupt <b>OFS_ADC12IFG1</b> - Flag the 1st memory buffer interrupt <b>OFS_ADC12IFG2</b> - Flag the 2nd memory buffer interrupt <b>OFS_ADC12IFG3</b> - Flag the 3rd memory buffer interrupt <b>OFS_ADC12IFG4</b> - Flag the 4th memory buffer interrupt <b>OFS_ADC12IFG5</b> - Flag the 5th memory buffer interrupt <b>OFS_ADC12IFG6</b> - Flag the 6th memory buffer interrupt <b>OFS_ADC12IFG7</b> - Flag the 7th memory buffer interrupt <b>OFS_ADC12IFG8</b> - Flag the 8th memory buffer interrupt <b>OFS_ADC12IFG9</b> - Flag the 9th memory buffer interrupt <b>OFS_ADC12IFG10</b> - Flag the 10th memory buffer interrupt <b>OFS_ADC12IFG11</b> - Flag the 11th memory buffer interrupt <b>OFS_ADC12IFG12</b> - Flag the 12th memory buffer interrupt <b>OFS_ADC12IFG13</b> - Flag the 13th memory buffer interrupt <b>OFS_ADC12IFG14</b> - Flag the 14th memory buffer interrupt <b>OFS_ADC12IFG15</b> - Flag the 15th memory buffer interrupt</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the status of the selected memory interrupt flags. Note that the overflow interrupts do not have an interrupt flag to clear; they must be accessed directly from the interrupt vector. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current interrupt flag status for the corresponding mask. </dd></dl>

<p>References <a class="el" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a class="anchor" id="a297b08a9a330166818a3991eb220177e"></a><!-- doxytag: member="adc12.c::ADC12_startConversion" ref="a297b08a9a330166818a3991eb220177e" args="(unsigned int baseAddress, unsigned int startingMemoryBufferIndex, unsigned char conversionSequenceModeSelect)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_startConversion </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>startingMemoryBufferIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>conversionSequenceModeSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enables/Starts an Analog-to-Digital Conversion.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12 module. </td></tr>
    <tr><td class="paramname">startingMemoryBufferIndex</td><td>is the memory buffer that will hold the first or only conversion. Valid values are <b>ADC12_MEMORY_0</b> [Default] <b>ADC12_MEMORY_1</b> <b>ADC12_MEMORY_2</b> <b>ADC12_MEMORY_3</b> <b>ADC12_MEMORY_4</b> <b>ADC12_MEMORY_5</b> <b>ADC12_MEMORY_6</b> <b>ADC12_MEMORY_7</b> <b>ADC12_MEMORY_8</b> <b>ADC12_MEMORY_9</b> <b>ADC12_MEMORY_10</b> <b>ADC12_MEMORY_11</b> <b>ADC12_MEMORY_12</b> <b>ADC12_MEMORY_13</b> <b>ADC12_MEMORY_14</b> <b>ADC12_MEMORY_15</b> Modified bits are <b>ADC12STARTADDx</b> of <b>ADC12CTL1</b> register. </td></tr>
    <tr><td class="paramname">conversionSequenceModeSelect</td><td>determines the ADC operating mode. Valid values are <b>ADC12_SINGLECHANNEL</b> - one-time conversion of a single channel into a single memory buffer. [Default] <b>ADC12_SEQOFCHANNELS</b> - one time conversion of multiple channels into the specified starting memory buffer and each subsequent memory buffer up until the conversion is stored in a memory buffer dedicated as the end-of-sequence by the memory's control register. <b>ADC12_REPEATED_SINGLECHANNEL</b> - repeated conversions of one channel into a single memory buffer. <b>ADC12_REPEATED_SEQOFCHANNELS</b> - repeated conversions of multiple channels into the specified starting memory buffer and each subsequent memory buffer up until the conversion is stored in a memory buffer dedicated as the end-of-sequence by the memory's control register. Modified bits are <b>ADC12CONSEQx</b> of <b>ADC12CTL1</b> register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables/starts the conversion process of the ADC. If the sample/hold signal source chosen during initialization was ADC12OSC, then the conversion is started immediately, otherwise the chosen sample/hold signal source starts the conversion by a rising edge of the signal. Keep in mind when selecting conversion modes, that for sequenced and/or repeated modes, to keep the sample/hold-and-convert process continuing without a trigger from the sample/hold signal source, the multiple samples must be enabled using the <a class="el" href="adc12_8c.html#abe73e4377d4898106655cdff1bb77b9a">ADC12_setupSamplingTimer()</a> function. Note that after this function is called, the ADC12_stopConversions() has to be called to re-initialize the ADC, reconfigure a memory buffer control, enable/disable the sampling timer, or to change the internal reference voltage.</p>
<p>Modified registers are <b>ADC12CTL0</b> and <b>ADC12CTL1</b>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

<p>References <a class="el" href="adc12_8h.html#a62fd4ee96c1eae548fdf8bca1fc8e259">ADC12_MEMORY_15</a>, <a class="el" href="adc12_8h.html#ad8f991e27547b3278b5d0b96ae540534">ADC12_REPEATED_SEQOFCHANNELS</a>, <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__types_8h.html#a084083ee12e5262f8e54bb56c15ac8c7">HWREGB</a>.</p>

</div>
</div>
<a class="anchor" id="a7a81cbe39c2fdd262cbdd6407559a882"></a><!-- doxytag: member="adc12.c::ADC12_disableConversions" ref="a7a81cbe39c2fdd262cbdd6407559a882" args="(unsigned int baseAddress, unsigned short preempt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_disableConversions </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>preempt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disables the ADC from converting any more signals.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12 module. </td></tr>
    <tr><td class="paramname">preempt</td><td>specifies if the current conversion should be preemptly stopped before the end of the conversion. Valid values are <b>ADC12_COMPLETECONVERSION</b> - Allows the ADC12 to end the current conversion before disabling conversions. <b>ADC12_PREEMPTCONVERSION</b> - Stops the ADC12 immediatly, with unpredicatble results of the current conversion.</td></tr>
  </table>
  </dd>
</dl>
<p>Disables the ADC from converting any more signals. If there is a conversion in progress, this function can stop it immediatly if the preempt parameter is set as TRUE, by changing the conversion mode to single-channel, single-conversion and disabling conversions. If the conversion mode is set as single-channel, single-conversion and this function is called without preemption, then the ADC core conversion status is polled until the conversion is complete before disabling conversions to prevent unpredictable data. If the <a class="el" href="adc12_8c.html#a297b08a9a330166818a3991eb220177e">ADC12_startConversion()</a> has been called, then this function has to be called to re-initialize the ADC, reconfigure a memory buffer control, enable/disable the sampling pulse mode, or change the internal reference voltage.</p>
<p>Modified registers are <b>ADC12CTL0</b> and <b>ADC12CTL1</b>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

<p>References <a class="el" href="adc12_8c.html#ad353c636458e86515ff6f522d61f7fe9">ADC12_isBusy()</a>, <a class="el" href="adc12_8h.html#a0c9a03d0eced6ec5f648cde617c16cfa">ADC12_PREEMPTCONVERSION</a>, and <a class="el" href="hw__types_8h.html#a084083ee12e5262f8e54bb56c15ac8c7">HWREGB</a>.</p>

</div>
</div>
<a class="anchor" id="a1f625d54871ddb415f907f9b3e7c4b2f"></a><!-- doxytag: member="adc12.c::ADC12_getResults" ref="a1f625d54871ddb415f907f9b3e7c4b2f" args="(unsigned int baseAddress, unsigned char memoryBufferIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ADC12_getResults </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>memoryBufferIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the raw contents of the specified memory buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12 module. </td></tr>
    <tr><td class="paramname">memryBufferIndex</td><td>is the specified Memory Buffer to read. Valid values are <b>ADC12_MEMORY_0</b> [Default] <b>ADC12_MEMORY_1</b> <b>ADC12_MEMORY_2</b> <b>ADC12_MEMORY_3</b> <b>ADC12_MEMORY_4</b> <b>ADC12_MEMORY_5</b> <b>ADC12_MEMORY_6</b> <b>ADC12_MEMORY_7</b> <b>ADC12_MEMORY_8</b> <b>ADC12_MEMORY_9</b> <b>ADC12_MEMORY_10</b> <b>ADC12_MEMORY_11</b> <b>ADC12_MEMORY_12</b> <b>ADC12_MEMORY_13</b> <b>ADC12_MEMORY_14</b> <b>ADC12_MEMORY_15</b> </td></tr>
  </table>
  </dd>
</dl>
<p>Returns the raw contents of the specified memory buffer. The format of the content depends on the read-back format of the data: if the data is in signed 2's complement format then the contents in the memory buffer will be left-justified with the least-siginificant bits as 0's, whereas if the data is in unsigned format then the contents in the memory buffer will be right-justified with the most-significant bits as 0's.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A Signed Integer of the contents of the specified memory buffer. </dd></dl>

<p>References <a class="el" href="adc12_8h.html#a62fd4ee96c1eae548fdf8bca1fc8e259">ADC12_MEMORY_15</a>, <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, and <a class="el" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>.</p>

</div>
</div>
<a class="anchor" id="a8d7dbf6939271d728126e3898ccf84ba"></a><!-- doxytag: member="adc12.c::ADC12_setResolution" ref="a8d7dbf6939271d728126e3898ccf84ba" args="(unsigned int baseAddress, unsigned char resolutionSelect)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_setResolution </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>resolutionSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Use to change the resolution of the converted data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12 module. </td></tr>
    <tr><td class="paramname">resolutionSelect</td><td>determines the resolution of the converted data. Valid values are <b>ADC12_RESOLUTION_8BIT</b> <b>ADC12_RESOLUTION_10BIT</b> <b>ADC12_RESOLUTION_12BIT</b> [Default] Modified bits are <b>ADC12RESx</b> of <b>ADC12CTL2</b> register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function can be used to change the resolution of the converted data from the default of 12-bits.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

<p>References <a class="el" href="adc12_8h.html#aa535fb5748267adbd3569c5b0e46ce37">ADC12_RESOLUTION_12BIT</a>, <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, and <a class="el" href="hw__types_8h.html#a084083ee12e5262f8e54bb56c15ac8c7">HWREGB</a>.</p>

</div>
</div>
<a class="anchor" id="a8306114b51f21a79105ffd6808697604"></a><!-- doxytag: member="adc12.c::ADC12_setSampleHoldSignalInversion" ref="a8306114b51f21a79105ffd6808697604" args="(unsigned int baseAddress, unsigned int invertedSignal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_setSampleHoldSignalInversion </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>invertedSignal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Use to invert or un-invert the sample/hold signal.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12 module. </td></tr>
    <tr><td class="paramname">invertedSignal</td><td>set if the sample/hold signal should be inverted Valid values are <b>ADC12_NONINVERTEDSIGNAL</b> - a sample-and-hold of an input signal for conversion will be started on a rising edge of the sample/hold signal. [Default] <b>ADC12_INVERTEDSIGNAL</b> - a sample-and-hold of an input signal for conversion will be started on a falling edge of the sample/hold signal. Modified bits are <b>ADC12ISSH</b> of <b>ADC12CTL1</b> register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function can be used to invert or un-invert the sample/hold signal. Note that if a conversion has been started with the startConversion() function, then a call to disableConversions() is required before this function may be called.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="hw__types_8h.html#ac9660181819fceac0b5abcd67d76ca6e">HWREG</a>, and <a class="el" href="hw__types_8h.html#a084083ee12e5262f8e54bb56c15ac8c7">HWREGB</a>.</p>

</div>
</div>
<a class="anchor" id="a045b246fcc1155af2a579acd0b02796a"></a><!-- doxytag: member="adc12.c::ADC12_setDataReadBackFormat" ref="a045b246fcc1155af2a579acd0b02796a" args="(unsigned int baseAddress, unsigned short readBackFormat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_setDataReadBackFormat </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>readBackFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Use to set the read-back format of the converted data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12 module. </td></tr>
    <tr><td class="paramname">readBackFormat</td><td>is the specified format to store the conversions in the memory buffer. Valid values are <b>ADC12_UNSIGNED_BINARY</b> [Default] <b>ADC12_SIGNED_2SCOMPLEMENT</b> Modified bits are <b>ADC12DF</b> of <b>ADC12CTL2</b> register.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets the format of the converted data: how it will be stored into the memory buffer, and how it should be read back. The format can be set as right-justified (default), which indicates that the number will be unsigned, or left-justified, which indicates that the number will be signed in 2's complement format. This change affects all memory buffers for subsequent conversions.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

<p>References <a class="el" href="adc12_8h.html#acddf92648febdcdbf14e190bee8ddbc5">ADC12_SIGNED_2SCOMPLEMENT</a>, <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, and <a class="el" href="hw__types_8h.html#a084083ee12e5262f8e54bb56c15ac8c7">HWREGB</a>.</p>

</div>
</div>
<a class="anchor" id="a38cf5c993556c54a83ae9e69f09abba2"></a><!-- doxytag: member="adc12.c::ADC12_enableReferenceBurst" ref="a38cf5c993556c54a83ae9e69f09abba2" args="(unsigned int baseAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_enableReferenceBurst </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>baseAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enables the reference buffer's burst ability.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12 module.</td></tr>
  </table>
  </dd>
</dl>
<p>Enables the reference buffer's burst ability, allowing the reference buffer to turn off while the ADC is not converting, and automatically turning on when the ADC needs the generated reference voltage for a conversion.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

<p>References <a class="el" href="hw__types_8h.html#a084083ee12e5262f8e54bb56c15ac8c7">HWREGB</a>.</p>

</div>
</div>
<a class="anchor" id="a82ea657873bd5d0d42109f536687a240"></a><!-- doxytag: member="adc12.c::ADC12_disableReferenceBurst" ref="a82ea657873bd5d0d42109f536687a240" args="(unsigned int baseAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_disableReferenceBurst </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>baseAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disables the reference buffer's burst ability.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12 module.</td></tr>
  </table>
  </dd>
</dl>
<p>Disables the reference buffer's burst ability, forcing the reference buffer to remain on continuously.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

<p>References <a class="el" href="hw__types_8h.html#a084083ee12e5262f8e54bb56c15ac8c7">HWREGB</a>.</p>

</div>
</div>
<a class="anchor" id="aa6a7531c03e3a27259a87a6b117c6f3b"></a><!-- doxytag: member="adc12.c::ADC12_setReferenceBufferSamplingRate" ref="aa6a7531c03e3a27259a87a6b117c6f3b" args="(unsigned int baseAddress, unsigned short samplingRateSelect)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ADC12_setReferenceBufferSamplingRate </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>samplingRateSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Use to set the reference buffer's sampling rate.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12 module. </td></tr>
    <tr><td class="paramname">samplingRateSelect</td><td>is the specified maximum sampling rate. Valid values are <b>ADC12_MAXSAMPLINGRATE_200KSPS</b> [Default] <b>ADC12_MAXSAMPLINGRATE_50KSPS</b> Modified bits are <b>ADC12SR</b> of <b>ADC12CTL2</b> register.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets the reference buffer's sampling rate to the selected sampling rate. The default sampling rate is maximum of 200-ksps, and can be reduced to a maximum of 50-ksps to conserve power.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

<p>References <a class="el" href="adc12_8h.html#a51dbfa2da6b976ff919180195bb9f6fd">ADC12_MAXSAMPLINGRATE_50KSPS</a>, <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, and <a class="el" href="hw__types_8h.html#a084083ee12e5262f8e54bb56c15ac8c7">HWREGB</a>.</p>

</div>
</div>
<a class="anchor" id="a020dda8a075980e22bf9f98e45ef1164"></a><!-- doxytag: member="adc12.c::ADC12_getMemoryAddressForDMA" ref="a020dda8a075980e22bf9f98e45ef1164" args="(unsigned int baseAddress, unsigned char memoryIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long ADC12_getMemoryAddressForDMA </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>memoryIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the address of the specified memory buffer for the DMA module.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12 module. </td></tr>
    <tr><td class="paramname">memoryIndex</td><td>is the memory buffer to return the address of. Valid values are <b>ADC12_MEMORY_0</b> [Default] <b>ADC12_MEMORY_1</b> <b>ADC12_MEMORY_2</b> <b>ADC12_MEMORY_3</b> <b>ADC12_MEMORY_4</b> <b>ADC12_MEMORY_5</b> <b>ADC12_MEMORY_6</b> <b>ADC12_MEMORY_7</b> <b>ADC12_MEMORY_8</b> <b>ADC12_MEMORY_9</b> <b>ADC12_MEMORY_10</b> <b>ADC12_MEMORY_11</b> <b>ADC12_MEMORY_12</b> <b>ADC12_MEMORY_13</b> <b>ADC12_MEMORY_14</b> <b>ADC12_MEMORY_15</b> </td></tr>
  </table>
  </dd>
</dl>
<p>Returns the address of the specified memory buffer. This can be used in conjunction with the DMA to store the converted data directly to memory.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="ad353c636458e86515ff6f522d61f7fe9"></a><!-- doxytag: member="adc12.c::ADC12_isBusy" ref="ad353c636458e86515ff6f522d61f7fe9" args="(unsigned int baseAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short ADC12_isBusy </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>baseAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the busy status of the ADC12 core.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddress</td><td>is the base address of the ADC12 module.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the status of the ADC core if there is a conversion currently taking place.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>ADC12_BUSY or ADC12_NOTBUSY dependent if there is a conversion currently taking place. </dd></dl>

<p>References <a class="el" href="adc12_8h.html#a8adf1577b784ab46e676449be0ddb1d8">ADC12_BUSY</a>, <a class="el" href="adc12_8h.html#a1c9e5c1354481f50abaf8012b17c7177">ADC12_NOTBUSY</a>, and <a class="el" href="hw__types_8h.html#a084083ee12e5262f8e54bb56c15ac8c7">HWREGB</a>.</p>

<p>Referenced by <a class="el" href="adc12_8h.html#a7a81cbe39c2fdd262cbdd6407559a882">ADC12_disableConversions()</a>.</p>

</div>
</div>
</div>
<hr size="1" /><small>
Copyright  2011, Texas Instruments Incorporated</small>
</body>
</html>
